<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>国际象棋双人对战平台 - 版本1.0.5</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
            transition: all 0.15s ease; /* 流畅过渡效果 */
        }
        body {
            background-color: #f5f5f5;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1200px;
        }
        .header h1 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 2.2rem;
        }
        .header .info {
            color: #666;
            font-size: 1.1rem;
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        .header .author {
            font-weight: 500;
        }
        .header .version {
            color: #3498db;
            font-weight: 600;
        }
        .container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }
        .game-panel {
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 18px;
            min-width: 280px;
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }
        .btn {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            background-color: #2c3e50;
            color: white;
            font-size: 17px;
            cursor: pointer;
            font-weight: 500;
        }
        .btn:hover {
            background-color: #34495e;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: none;
        }
        .status {
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 19px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f8f9fa;
            border: 1px solid #eee;
            font-weight: 500;
        }
        .status.win {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
            font-size: 21px;
            font-weight: 600;
        }
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 65px);
            grid-template-rows: repeat(8, 65px);
            border: 3px solid #2c3e50;
            border-radius: 4px;
        }
        .chessboard .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 42px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        .chessboard .square.white {
            background-color: #f0d9b5;
        }
        .chessboard .square.black {
            background-color: #b58863;
        }
        .chessboard .square.selected {
            background-color: #6ab04c;
            outline: 3px solid #4d7c37;
            z-index: 1;
        }
        .chessboard .square.valid-move::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: rgba(106, 176, 76, 0.8);
        }
        .chessboard .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 45px;
            height: 45px;
            border: 3px dashed rgba(106, 176, 76, 0.8);
            border-radius: 50%;
        }
        .chessboard .square.king-in-check {
            background-color: #e74c3c !important; /* 将军时红色底色 */
            animation: pulse 1.2s infinite alternate;
        }
        @keyframes pulse {
            from { opacity: 0.8; }
            to { opacity: 1; }
        }
        .rules-panel {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            max-width: 1000px;
            width: 100%;
            margin-top: 30px;
        }
        .rules-panel h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 12px;
            font-size: 1.8rem;
        }
        .rules-panel h3 {
            color: #3498db;
            margin: 20px 0 12px;
            font-size: 1.4rem;
        }
        .rules-panel p {
            line-height: 1.7;
            margin-bottom: 12px;
            color: #555;
            font-size: 1.05rem;
        }
        .rules-panel ul {
            margin-left: 25px;
            margin-bottom: 18px;
            color: #555;
        }
        .rules-panel li {
            line-height: 1.6;
            margin-bottom: 8px;
            font-size: 1.05rem;
        }
        .rules-panel strong {
            color: #2c3e50;
        }
        @media (max-width: 992px) {
            .chessboard {
                grid-template-columns: repeat(8, 55px);
                grid-template-rows: repeat(8, 55px);
            }
            .chessboard .square {
                font-size: 36px;
            }
        }
        @media (max-width: 768px) {
            .chessboard {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }
            .chessboard .square {
                font-size: 28px;
            }
            .container {
                gap: 20px;
            }
            .control-panel {
                min-width: 100%;
                order: -1;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>国际象棋双人对战平台</h1>
        <div class="info">
            <div class="author">By Lusrem</div>
            <div class="version">版本 1.0.5</div>
        </div>
    </div>

    <div class="container">
        <div class="game-panel">
            <div class="chessboard" id="chessboard"></div>
        </div>

        <div class="control-panel">
            <button class="btn" id="restart">重新开始游戏</button>
            <div class="status" id="status">准备开始 - 白方先行</div>
        </div>
    </div>

    <div class="rules-panel">
        <h2>国际象棋完整规则</h2>
        
        <h3>1. 棋盘与棋子</h3>
        <p>棋盘为8×8黑白相间的方格，共64格。双方各有16枚棋子：1王、1后、2车、2象、2马、8兵。</p>
        <p>初始布局：白方棋子位于1-2行，黑方位于7-8行。后排从左到右：车、马、象、后、王、象、马、车；前排全为兵（白兵在第2行，黑兵在第7行）。</p>

        <h3>2. 棋子移动规则</h3>
        <ul>
            <li><strong>王</strong>：横、竖、斜走1格，不能送吃（进入被攻击的方格），不能被将军</li>
            <li><strong>后</strong>：横、竖、斜走任意格，不能越子，是威力最强的棋子</li>
            <li><strong>车</strong>：横、竖走任意格，不能越子，王车易位时可移动两格</li>
            <li><strong>象</strong>：斜走任意格，不能越子，始终在同一颜色方格（白象走白格，黑象走黑格）</li>
            <li><strong>马</strong>：走"日"字（2格+1格，如横2竖1或横1竖2），可越子，是唯一能越子的棋子</li>
            <li><strong>兵</strong>：
                <ul>
                    <li>第一步可走1或2格，之后只能向前走1格（白兵向上，黑兵向下）</li>
                    <li>直走斜吃，不能后退，只能攻击斜前方1格的对方棋子</li>
                    <li>到达对方底线（白兵到8行，黑兵到1行）必须升变（可选择后、车、象、马之一）</li>
                    <li>吃过路兵：对方兵从初始位置走两格，且与己方兵相邻时，己方兵可在下一步斜吃该兵</li>
                </ul>
            </li>
        </ul>

        <h3>3. 特殊规则</h3>
        <ul>
            <li><strong>王车易位</strong>：王和车均未移动过，之间无其他棋子，王不被将军，移动过程中也不被将军；王向车的方向移动两格，车移动到王的另一侧</li>
            <li><strong>兵的升变</strong>：兵到达对方底线必须升变，不能不变或升变为王，通常升变为后（威力最强）</li>
            <li><strong>吃过路兵</strong>：对方兵从初始位置（白兵第2行，黑兵第7行）走两格，且停在己方兵的相邻格时，己方兵可在下一步斜向吃掉该兵，停在对方兵原本应该到达的格子</li>
            <li><strong>逼和</strong>：一方无合法移动但未被将军，判和棋</li>
            <li><strong>长将</strong>：一方连续将军，另一方无法摆脱，判和棋</li>
            <li><strong>50步规则</strong>：连续50步无吃子、无兵移动，任何一方可提出和棋</li>
        </ul>

        <h3>4. 胜负判定</h3>
        <ul>
            <li><strong>将死</strong>：对方王被将军且无合法移动（无法躲将、挡将或吃子解将），己方获胜</li>
            <li><strong>王被吃掉</strong>：若对方王被己方棋子捕获，己方直接获胜（规则中不允许此情况，仅作为异常处理）</li>
            <li><strong>认输</strong>：一方主动认输，另一方获胜</li>
            <li><strong>超时</strong>：若有计时规则，超时方判负</li>
            <li><strong>和棋</strong>：逼和、长将、50步规则、双方同意和棋、局面重复三次</li>
        </ul>

        <h3>5. 游戏操作说明</h3>
        <p>1. 白方先行，双方轮流移动棋子，点击己方棋子选中（会显示合法移动标记），再点击目标位置完成移动</p>
        <p>2. 合法移动标记：圆点=可移动到空方格，虚线圆=可吃对方棋子</p>
        <p>3. 将军提示：<strong>无论当前是谁的回合，只要王被将军，对应方格会立即变红闪烁</strong>，需立即解将</p>
        <p>4. 获胜提示：将死或吃掉对方王后，游戏立即结束，状态栏显示获胜方信息，棋盘保留最终局面</p>
    </div>

    <script>
        // 棋子类型与Unicode符号（统一显示风格）
        const pieces = {
            'wK': '♔', 'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘', 'wP': '♙',
            'bK': '♚', 'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞', 'bP': '♟'
        };

        // 游戏状态（优化初始值）
        let gameState = {
            board: [],
            currentPlayer: 'white', // white/black
            selectedSquare: null,
            validMoves: [],
            isGameOver: false,
            moveCount: 0,
            kingPositions: { white: { row: 7, col: 4 }, black: { row: 0, col: 4 } } // 记录王的位置，优化将军判断
        };

        // 初始化棋盘
        function initBoard() {
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            // 黑方后排（第0行）
            board[0] = ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'];
            // 黑方兵（第1行）
            board[1] = Array(8).fill('bP');
            // 白方兵（第6行）
            board[6] = Array(8).fill('wP');
            // 白方后排（第7行）
            board[7] = ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR'];
            
            gameState.board = board;
            gameState.kingPositions = {
                white: { row: 7, col: 4 },
                black: { row: 0, col: 4 }
            };
            renderBoard();
            updateStatus('准备开始 - 白方先行');
        }

        // 渲染棋盘（优化性能，减少DOM操作）
        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';
            
            // 获取所有被将军的王的位置（白王+黑王）
            const checkedKings = getAllCheckedKings();
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isWhiteSquare = (row + col) % 2 === 0;
                    square.className = `square ${isWhiteSquare ? 'white' : 'black'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // 添加棋子
                    const piece = gameState.board[row][col];
                    if (piece) {
                        square.textContent = pieces[piece];
                        square.dataset.piece = piece;
                    }
                    
                    // 标记选中的方格
                    if (gameState.selectedSquare && 
                        gameState.selectedSquare.row === row && 
                        gameState.selectedSquare.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // 标记合法移动
                    if (gameState.validMoves.some(move => move.row === row && move.col === col)) {
                        const targetPiece = gameState.board[row][col];
                        targetPiece ? square.classList.add('valid-capture') : square.classList.add('valid-move');
                    }
                    
                    // 标记被将军的王（白王/黑王都检测）
                    if (checkedKings.some(king => king.row === row && king.col === col)) {
                        square.classList.add('king-in-check');
                    }
                    
                    // 游戏结束后禁用点击
                    if (!gameState.isGameOver) {
                        square.addEventListener('click', () => handleSquareClick(row, col));
                    } else {
                        square.style.cursor = 'default'; // 鼠标样式改为默认，提示不可操作
                    }
                    
                    chessboard.appendChild(square);
                }
            }
        }

        // 处理方格点击（优化逻辑，提升操作流畅度）
        function handleSquareClick(row, col) {
            if (gameState.isGameOver) return;
            
            const clickedPiece = gameState.board[row][col];
            const isCurrentPlayerPiece = clickedPiece && clickedPiece.startsWith(gameState.currentPlayer === 'white' ? 'w' : 'b');
            
            // 点击己方棋子：选中并显示合法移动
            if (isCurrentPlayerPiece) {
                // 如果已经选中当前玩家的其他棋子，直接切换选中
                if (gameState.selectedSquare && 
                    gameState.selectedSquare.piece.startsWith(gameState.currentPlayer === 'white' ? 'w' : 'b')) {
                    gameState.selectedSquare = { row, col, piece: clickedPiece };
                    gameState.validMoves = getValidMoves(row, col);
                    renderBoard();
                    return;
                }
                gameState.selectedSquare = { row, col, piece: clickedPiece };
                gameState.validMoves = getValidMoves(row, col);
                renderBoard();
                return;
            }
            
            // 已经选中棋子，尝试移动
            if (gameState.selectedSquare) {
                const isValidMove = gameState.validMoves.some(move => move.row === row && move.col === col);
                
                if (isValidMove) {
                    // 检查目标位置是否是对方的王（王被吃掉的情况）
                    const targetPiece = gameState.board[row][col];
                    if (targetPiece === 'wK' || targetPiece === 'bK') {
                        // 王被吃掉，当前玩家胜利
                        makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                        gameState.isGameOver = true;
                        updateStatus(`${gameState.currentPlayer === 'white' ? '白' : '黑'}方吃掉对方王，获得胜利！`, true);
                        renderBoard(); // 渲染最终棋盘
                        return;
                    }
                    
                    // 执行正常移动
                    makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                    // 重置选中状态
                    gameState.selectedSquare = null;
                    gameState.validMoves = [];
                    
                    // 检查是否将死
                    const gameResult = checkGameOver();
                    if (gameResult) {
                        gameState.isGameOver = true;
                        updateStatus(gameResult, true);
                        renderBoard(); // 渲染最终棋盘
                        return;
                    }
                    
                    // 切换玩家
                    gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
                    updateStatus(`${gameState.currentPlayer === 'white' ? '白' : '黑'}方回合`);
                    
                    // 渲染更新后的棋盘
                    renderBoard();
                } else {
                    // 点击无效位置，取消选中（点击对方棋子或空方格）
                    gameState.selectedSquare = null;
                    gameState.validMoves = [];
                    renderBoard();
                }
            }
        }

        // 获取合法移动（优化算法，提升计算速度）
        function getValidMoves(startRow, startCol) {
            const validMoves = [];
            const piece = gameState.board[startRow][startCol];
            if (!piece) return validMoves;
            
            const [color, type] = [piece[0], piece[1]];
            const isWhite = color === 'w';

            // 通用移动检查函数
            const addMoveIfValid = (newRow, newCol) => {
                if (isValidSquare(newRow, newCol)) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if (!targetPiece || targetPiece[0] !== color) {
                        validMoves.push({ row: newRow, col: newCol });
                    }
                }
            };

            // 直线移动检查函数（车、后）
            const checkLinearMoves = (directions) => {
                for (const [dr, dc] of directions) {
                    let r = startRow + dr;
                    let c = startCol + dc;
                    while (isValidSquare(r, c)) {
                        const targetPiece = gameState.board[r][c];
                        if (!targetPiece) {
                            validMoves.push({ row: r, col: c });
                        } else {
                            if (targetPiece[0] !== color) {
                                validMoves.push({ row: r, col: c });
                            }
                            break; // 遇到棋子停止
                        }
                        r += dr;
                        c += dc;
                    }
                }
            };

            // 根据棋子类型计算移动
            switch (type) {
                case 'K': // 王
                    const kingMoves = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
                    kingMoves.forEach(([dr, dc]) => addMoveIfValid(startRow + dr, startCol + dc));
                    break;

                case 'Q': // 后（直线+斜线）
                    checkLinearMoves([[-1,0], [1,0], [0,-1], [0,1]]); // 直线
                    checkLinearMoves([[-1,-1], [-1,1], [1,-1], [1,1]]); // 斜线
                    break;

                case 'R': // 车（直线）
                    checkLinearMoves([[-1,0], [1,0], [0,-1], [0,1]]);
                    break;

                case 'B': // 象（斜线）
                    checkLinearMoves([[-1,-1], [-1,1], [1,-1], [1,1]]);
                    break;

                case 'N': // 马
                    const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                    knightMoves.forEach(([dr, dc]) => addMoveIfValid(startRow + dr, startCol + dc));
                    break;

                case 'P': // 兵
                    const direction = isWhite ? -1 : 1;
                    // 前进1格
                    if (isValidSquare(startRow + direction, startCol) && !gameState.board[startRow + direction][startCol]) {
                        addMoveIfValid(startRow + direction, startCol);
                        // 初始位置前进2格
                        const isInitial = (isWhite && startRow === 6) || (!isWhite && startRow === 1);
                        if (isInitial && !gameState.board[startRow + 2*direction][startCol]) {
                            addMoveIfValid(startRow + 2*direction, startCol);
                        }
                    }
                    // 斜向吃子
                    const captureCols = [startCol - 1, startCol + 1];
                    captureCols.forEach(col => {
                        const r = startRow + direction;
                        if (isValidSquare(r, col) && gameState.board[r][col] && gameState.board[r][col][0] !== color) {
                            validMoves.push({ row: r, col });
                        }
                    });
                    break;
            }

            return validMoves;
        }

        // 检查方格是否有效（在棋盘内）
        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // 执行移动（优化王的位置记录）
        function makeMove(startRow, startCol, endRow, endCol) {
            const piece = gameState.board[startRow][startCol];
            // 更新王的位置
            if (piece === 'wK') {
                gameState.kingPositions.white = { row: endRow, col: endCol };
            } else if (piece === 'bK') {
                gameState.kingPositions.black = { row: endRow, col: endCol };
            }
            // 执行移动
            gameState.board[endRow][endCol] = piece;
            gameState.board[startRow][startCol] = null;
            // 兵升变（自动升变为后，符合常规操作）
            if (piece.includes('P') && (endRow === 0 || endRow === 7)) {
                const color = piece[0];
                gameState.board[endRow][endCol] = color + 'Q';
            }
            gameState.moveCount++;
        }

        // 新增：检测所有被将军的王（白王+黑王）
        function getAllCheckedKings() {
            const checkedKings = [];
            // 检测白王是否被黑方攻击
            if (isSquareAttacked(gameState.kingPositions.white.row, gameState.kingPositions.white.col, 'b')) {
                checkedKings.push(gameState.kingPositions.white);
            }
            // 检测黑王是否被白方攻击
            if (isSquareAttacked(gameState.kingPositions.black.row, gameState.kingPositions.black.col, 'w')) {
                checkedKings.push(gameState.kingPositions.black);
            }
            return checkedKings;
        }

        // 检查指定方格是否被某颜色棋子攻击
        function isSquareAttacked(row, col, attackerColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = gameState.board[r][c];
                    if (piece && piece[0] === attackerColor) {
                        const moves = getValidMoves(r, c);
                        if (moves.some(move => move.row === row && move.col === col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 废弃原有的单王检测函数，改用getAllCheckedKings
        function getCheckedKingPosition() {
            const checkedKings = getAllCheckedKings();
            return checkedKings.length > 0 ? checkedKings[0] : null;
        }

        // 检查游戏是否结束（完善将死判断）
        function checkGameOver() {
            const opponent = gameState.currentPlayer === 'white' ? 'black' : 'white';
            const kingPos = gameState.kingPositions[opponent];
            
            // 检查对方是否被将军
            const isInCheck = isSquareAttacked(kingPos.row, kingPos.col, gameState.currentPlayer === 'white' ? 'w' : 'b');
            
            // 检查对方是否有合法移动
            let hasValidMoves = false;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece && piece.startsWith(opponent === 'white' ? 'w' : 'b')) {
                        const moves = getValidMoves(row, col);
                        if (moves.length > 0) {
                            hasValidMoves = true;
                            break;
                        }
                    }
                }
                if (hasValidMoves) break;
            }
            
            // 将死：被将军且无合法移动
            if (isInCheck && !hasValidMoves) {
                return `${gameState.currentPlayer === 'white' ? '白' : '黑'}方将死对方，获得胜利！`;
            }
            
            // 逼和：未被将军但无合法移动
            if (!isInCheck && !hasValidMoves) {
                return '双方逼和，游戏结束！';
            }
            
            // 50步规则（简化为100步，避免过早结束）
            if (gameState.moveCount >= 100) {
                return '连续100步无吃子无兵移动，判为和棋！';
            }
            
            return null;
        }

        // 更新状态信息（支持获胜样式）
        function updateStatus(message, isWin = false) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            if (isWin) {
                statusEl.classList.add('win');
            } else {
                statusEl.classList.remove('win');
            }
        }

        // 初始化游戏
        function initGame() {
            gameState = {
                board: [],
                currentPlayer: 'white',
                selectedSquare: null,
                validMoves: [],
                isGameOver: false,
                moveCount: 0,
                kingPositions: { white: { row: 7, col: 4 }, black: { row: 0, col: 4 } }
            };
            initBoard();
            // 重置状态栏样式
            document.getElementById('status').classList.remove('win');
        }

        // 绑定重新开始按钮事件
        document.getElementById('restart').addEventListener('click', initGame);

        // 初始化游戏
        initGame();
    </script>
</body>
</html>
